/*=========================================================================

    Copyright Â© 2011 BIREME/PAHO/WHO

    This file is part of Bruma.

    Bruma is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, either version 3 of
    the License, or (at your option) any later version.

    Bruma is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with Bruma. If not, see <http://www.gnu.org/licenses/>.

=========================================================================*/

package bruma.master;

import bruma.BrumaException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * <p>The <code>Record</code> class represents an Isis database record.
 * </p>
 * @author Heitor Barbieri
 */
public class Record implements Iterable<Field> {

    /** Default Isis database record type. */
    public static final int DEFAULT_SHIFT = 3;
    /** Default Isis database memory shift. */
    public static final int ISIS_STANDARD_SHIFT = 0;

    /** Tells if the record is active or deleted. */
    public static enum Status { ACTIVE, LOGDEL, PHYDEL };
    /** Tells the status of an active record. */
    public static enum ActiveStatus { NORMAL, NEW, PENDING };
    /** Tells if a record is locked or not. */
    public static enum LockStatus { NORMAL, LOCKED };

    private static final int DEFAULT_FILLER =
           ((System.getProperty("os.name").startsWith("Win") == false) ? 2 : 0);
    private static final String DEFAULT_LINE_SEPARATOR =
                                           System.getProperty("line.separator");

    private final List<Field> fields;
    private final String separator;  // end of line symbol
    private  int filler;  // 2 bytes para ajuste de alinhamento da estrutura M1STRU
    private int shift;
    private Status status;
    private ActiveStatus actStatus;
    private LockStatus lckStatus;
    private int mfn;
    private int mfbwb;
    private int mfbwp;
    //private Map<Integer,String> tags;
    //private Map<String,Integer> stags;

    /**
     *  Creates a new instance of <code>Record</code>.
     * It uses the DEFAULT database shift and platform native byte order.
     * @see ISIS_STANDARD_SHIFT
     * @exception  BrumaException
     */
    public Record() throws BrumaException {
        this(ISIS_STANDARD_SHIFT, DEFAULT_FILLER);
    }

    /*
     * Creates a new instance of <code>Record</code>.
     *
     */
    public Record(final int shift,
                  final int filler) throws BrumaException {
        if (shift < 0) {
            throw new BrumaException("illegal shift[" + shift + "]");
        }
        if (filler < 0) {
            throw new BrumaException("illegal shift[" + filler + "]");
        }
        this.shift = shift;
        fields = new ArrayList<Field>(50);
        status = Status.ACTIVE;
        actStatus = ActiveStatus.NORMAL;
        lckStatus = LockStatus.NORMAL;
        mfn = 0;
        mfbwb = 0;
        mfbwp = 0;
        this.filler = filler;
        separator = DEFAULT_LINE_SEPARATOR;
        //tags = null;
        //stags = null;
    }

    /**
     * Converts a pseudo xml document (same format as generated by toString()
     * function) into a Record object.
     * @param xml a string with xml document.
     * @exception BrumaException
     * @return an Record object.
     */
    public static Record fromString(final String xml) throws BrumaException {
        return fromString(xml,ISIS_STANDARD_SHIFT, DEFAULT_FILLER);
    }

    public static Record fromString(final String xml,
                                    final int shift,
                                    final int filler) throws BrumaException {
        if (xml == null) {
            throw new IllegalArgumentException("null xml");
        }
        final Matcher openRecMat = Pattern.compile(
                      "(?i)\\s*<\\s*record(\\s+mfn='\\d+')?(\\s+nvf='\\d+')?"
                              + "(\\s+status='(.+?)')?\\s*>\\s*").matcher(xml);
        final Matcher closeRecMat = Pattern.compile(
                             "(?i)\\s*<\\s*/\\s*record\\s*>\\s*").matcher(xml);
        final Matcher fldMat = Pattern.compile(
                "<\\s*([^>]+)\\s*>((?s)(.*?))<\\s*/\\s*\\1\\s*>").matcher(xml);
        final Matcher tagMat = Pattern.compile("<\\s*([^>]+)\\s*>").matcher("");
        final Record rec = new Record(shift, filler);
        final int len = xml.length();
        int curPos = 0;
        int tag;
        char ch;
        boolean hasOpenRec = false;

        if (openRecMat.find(curPos)) {
            curPos = openRecMat.end();
            hasOpenRec = true;
        }
        while (true) {
            while (curPos < len) {
                ch = xml.charAt(curPos);
                if ((ch != ' ') && (ch != '\t') &&
                    (ch != '\n') && (ch != '\r')) {
                        break;
                }
                curPos++;
            }
            if (curPos == len) {
                if (hasOpenRec) {
                    throw new BrumaException("parse error: missing </record>");
                }
                break;
            }
            if (fldMat.find(curPos)) {
                if (fldMat.start() > curPos) {
                    throw new BrumaException("parse error pos:" + curPos);
                }
                tag = Integer.parseInt(fldMat.group(1));
                tagMat.reset(fldMat.group(2));
                if (tagMat.find()) {
                    throw new BrumaException("parse error:" + fldMat.group(2));
                }
                rec.addField(tag, fldMat.group(3));
                curPos = fldMat.end();
            } else {
                break;
            }
        }
        if (closeRecMat.find(curPos)) {
            if (!hasOpenRec) {
                throw new BrumaException("parse error: missing <record>");
            }
            curPos = closeRecMat.end();
            if (curPos != len) {
                throw new BrumaException("parse error pos:" + curPos);
            }
        }

        return rec;
    }

    /**
     * Returns the record length in bytes
     * @param encoding character encoding used in fields.
     * @param isFFI true if the database which will sttore the record is
     *        extended (FFI), false otherwise.
     * @return record length
     * @throws BrumaException
     */
    public int getRecordLength(final String encoding,
                               final boolean isFFI) throws BrumaException {
        assert encoding != null;

        final int size = fields.size();
        int ret = (isFFI ? 22 : 18) + filler + (size * (isFFI ?
                                                          (10 + filler) :  6));
//System.out.println("base=" + ret);
        try {
            for (Field field : fields) {
                ret += field.getContent().getBytes(encoding).length;
//System.out.println("fldlen=" + fe.field.getBytes(encoding).length);
            }
        } catch(Exception ex) {
            throw new BrumaException(ex);
        }
//System.out.println("totlen=" + ret);
        return ret + getFillSize(ret);
    }

    // Retorna o numero de espacos acrescentados ao registro para que o
    // registro seguinte seja gravado na posicao correta
    int getFillSize(final int recordLength) {
        // endereco inicial de cada registro
        final int addrBegin = ((shift == 0) ? 2 : (1 << shift));

        return (((recordLength % addrBegin) == 0) ? 0 :
                                    (addrBegin - (recordLength % addrBegin)));
    }

    int getBlockNumber() {
        return mfbwb;
    }

    void setBlockNumber(final int mfbwb) {
        assert  mfbwb >= 0;

        this.mfbwb = mfbwb;
    }

    int getBlockPos() {
        return mfbwp;
    }

    void setBlockPos(final int mfbwp) {
        assert mfbwp >= 0;

        this.mfbwp = mfbwp;
    }

    /**
      *  Get the master file record number.
      *
      * @return  the record master file number (mfn).
      */
    public int getMfn() {
        return mfn;
    }

    /**
     *  Get the record status.
     *
     * @return  the record status value.
     * @see Status
     */
    public Status getStatus() {
        return status;
    }

    void setStatus(final Status stat) {
        status = stat;
    }

    /**
     * Check if the record is active
     * @return true if the record is active, false otherwise
     */
    public boolean isActive() {
        return status == Status.ACTIVE;
    }

    /**
     *  Get the record status.
     *
     * @return  the record active status value.
     * @see ActiveStatus
     */
    public ActiveStatus getActiveStatus() {
        return actStatus;
    }

    void setActiveStatus(final ActiveStatus stat) {
        actStatus = stat;
    }

    /**
     * Get the status of the record: normal or locked.
     * @return the lock status.
     */
    public LockStatus getLockStatus() {
        return lckStatus;
    }

    void setLockStatus(final LockStatus stat) {
        lckStatus = stat;
    }

    public void setShift(final int shift) {
        assert (shift >= 0);

        this.shift = shift;
    }

    public void setFiller(final int filler) {
        assert (filler >= 0);

        this.filler = filler;
    }

   /**
     *  Get a set of all record tags.
     *
     * @return  the record tags list.
     */
    public Set<Integer> getRecordTags() {
        final Set<Integer> ret = new HashSet<Integer> ();

        for (Field field : fields) {
            ret.add(field.getId());
        }

        return ret;
    }

    /**
     *  Get a set of all record tag strings.
     *
     * @return  the record tag string list.
     */
    public Set<String> getRecordTagString() {
        final Set<String> ret = new HashSet<String> ();

        for (Field field : fields) {
            ret.add(field.getIdStr());
        }

        return ret;
    }

    /**
     *  Get the record number of variable fields
     *
     * @return  the record number of variable fields
     */
    public int getNvf() {
        return fields.size();
    }

    /**
      *  Get the record leader structure.
      *
      * @param encoding record fields encoding
      * @param isFFI master type FFI = true or Isis Standard = false
      * @return  the record leader structure object (<code>Leader</code>).
      * @see Leader
      * @exception  BrumaException
      */
    public Leader getLeader(final String encoding,
                            final boolean isFFI) throws BrumaException {
        final int size = fields.size();
        final int recLen = getRecordLength(encoding, isFFI);
        final int auxBase = ((isFFI ? 22 : 18) + filler +
                                (size * (isFFI ? (10 + filler) : 6)));

//System.out.println("getRecordLength=" + getRecordLength(encod)
// + " getFillSize=" + getFillSize(encod));
        return new Leader(mfn, (recLen + getFillSize(recLen)), mfbwb, mfbwp,
                          auxBase, size, status);
    }

    /**
     *  Get a record directory entry.
     *
     * @param pos position of the directory entry (pos >= 0).
     * @return  the record directory entry object (<code>DirEntry</code>)
     * @see DirEntry
     * @exception  BrumaException
     */
    public DirEntry getDirectoryEntry(final int pos) throws BrumaException {
        if  ((pos < 0) || (pos >= fields.size())) {
            throw new BrumaException("position[" + pos +
                    "] is out of range [0, " + (fields.size() - 1) + "]");
        }
        final Field field = fields.get(pos);

        return new DirEntry(field.getId(), field.getContent().length());
    }

    /**
     *  Get the number of occurrences of a field.
     * @param tag field tag
     * @return the number of occurrences of a field
     * @exception  BrumaException
     */
    public int getFieldOccs(final int tag) throws BrumaException {
        if (tag <= 0) {
            throw new BrumaException("parameter out of range tag["
                                                            + tag + "] <= 0");
        }

        final int len = fields.size();
        int pos = 0;
        int occ = 0;
        Field field;

        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getId() == tag) {
                occ++;
            }
            pos++;
        }

        return occ;
    }

    /**
     *  Get a record field.
     *
     * @param pos position of the field in the record directory(pos >= 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public Field getField(final int pos) throws BrumaException {
        if  ((pos < 0) || (pos >= fields.size())) {
            throw new BrumaException("parameter out of range [0, " +
                                                    (fields.size() - 1) + "]");
        }
        return fields.get(pos);
    }

    /**
     *  Get a record field.
     *
     * @param tag the field tag (tag > 0).
     * @param occ the field tag occurrence (occ > 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public Field getField(final int tag,
                          final int occ) throws BrumaException {
        final int len = fields.size();
        Field ret = null;
        int pos = 0;
        int auxOcc = 0;
        Field field;

        if (tag <= 0) {
            throw new BrumaException("parameter out of range tag[" +
                                                            tag + "] <= 0");
        }
        if  (occ <= 0) {
            throw new BrumaException("parameter out of range occ[" +
                                                            occ + "] <= 0");
        }
        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getId() == tag) {
                auxOcc++;
                if (auxOcc == occ) {
                    ret = field;
                    break;
                }
            }
            pos++;
        }
        return ret;
    }

    /**
     *  Get a record field.
     *
     * @param tagStr the field tag string.
     * @param occ the field tag string occurrence (occ > 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public Field getField(final String tagStr,
                          final int occ) throws BrumaException {
        final int len = fields.size();
        Field ret = null;
        int pos = 0;
        int auxOcc = 0;
        Field field;

        if (tagStr == null) {
            throw new BrumaException("null tagStr");
        }
        if  (occ <= 0) {
            throw new BrumaException("parameter out of range occ[" +
                                                            occ + "] <= 0");
        }
        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getIdStr().equals(tagStr)) {
                auxOcc++;
                if (auxOcc == occ) {
                    ret = field;
                    break;
                }
            }
            pos++;
        }
        return ret;
    }

    /**
     *  Get all occurrences of a record field.
     *
     * @param tag the field tag (tag > 0).
     * @return  the record field list.
     * @exception  BrumaException
     */
    public List<Field> getFieldList(final int tag) throws BrumaException {
        final List<Field> ret = new ArrayList<Field>();
        final int len = fields.size();
        int pos = 0;
        Field field;

        if (tag <= 0) {
            throw new BrumaException("parameter out of range tag[" +
                                                            tag + "] <= 0");
        }
        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getId() == tag) {
                ret.add(field);
            }
            pos++;
        }
        return ret;
    }

    /**
     *  Get all occurrences of a record field.
     *
     * @param tagStr the field tag string.
     * @return  the record field list.
     * @exception  BrumaException
     */
    public List<Field> getFieldList(final String tagStr) throws BrumaException {
        final List<Field> ret = new ArrayList<Field>();
        final int len = fields.size();
        int pos = 0;
        Field field;

        if (tagStr == null) {
            throw new BrumaException("null tagStr");
        }
        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getIdStr().equals(tagStr)) {
                ret.add(field);
            }
            pos++;
        }
        return ret;
    }

    /**
     *  Get a record field using the following xml format:
     *  &lt;tag&gt;field content&lt;/tag&gt&
     *
     * @param pos position of the field in the record directory(pos >= 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public String getFieldWithTag(final int pos) throws BrumaException {
        if ((pos < 0) || (pos >= fields.size())) {
            throw new BrumaException("parameter out of range [0, " +
                                                    (fields.size() - 1) + "]");
        }
        final Field field = fields.get(pos);

        return (field == null) ? null : field.toString();
    }

    /**
     *  Get a record field using the following xml format:
     *  &lt;field tag='tag'&gt;field content&lt;/field&gt&
     *
     * @param pos position of the field in the record directory(pos >= 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public String getFieldXML(final int pos) throws BrumaException {
        if ((pos < 0) || (pos >= fields.size())) {
            throw new BrumaException("parameter out of range [0, " +
                                                    (fields.size() - 1) + "]");
        }
        final Field field = fields.get(pos);

        return (field == null) ? null : field.toXML();
    }

    /**
     *  Get a record field using the following pseudo xml format:
     *  &lt;tag&gt;field content&lt;/tag&gt&
     *
     * @param tag the field tag (tag > 0).
     * @param occ the field tag occurrence (occ > 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public String getFieldWithTag(final int tag,
                                  final int occ) throws BrumaException {
        final int len = fields.size();
        Field field = null;
        int pos = 0;
        int auxOcc = 0;

        if (tag <= 0) {
            throw new BrumaException("parameter out of range tag[" + tag +
                                                                    "] <= 0");
        }
        if  (occ <= 0) {
            throw new BrumaException("parameter out of range occ[" + occ +
                                                                    "] <= 0");
        }
        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getId() == tag) {
                auxOcc++;
                if (auxOcc == occ) {
                    break;
                }
            }
            pos++;
        }
        return (field == null) ? null : field.toString();
    }

    /**
     *  Get a record field using the following pseudo xml format:
     *  &lt;tagStr&gt;field content&lt;/tagStr&gt&
     *
     * @param tagStr the field tag string.
     * @param occ the field tag occurrence (occ > 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public String getFieldWithTag(final String tagStr,
                                  final int occ) throws BrumaException {
        final int len = fields.size();
        Field field = null;
        int pos = 0;
        int auxOcc = 0;

        if (tagStr == null) {
            throw new BrumaException("null tagStr");
        }
        if  (occ <= 0) {
            throw new BrumaException("parameter out of range occ[" + occ +
                                                                    "] <= 0");
        }
        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getIdStr().equals(tagStr)) {
                auxOcc++;
                if (auxOcc == occ) {
                    break;
                }
            }
            pos++;
        }
        return (field == null) ? null : field.toString();
    }

    /**
     *  Get a record field using the following xml format:
     *  &lt;field tag='tag'&gt;field content&lt;/field&gt&
     *
     * @param tag the field tag (tag > 0).
     * @param occ the field tag occurrence (occ > 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public String getFieldXML(final int tag,
                              final int occ) throws BrumaException {
        final int len = fields.size();
        Field field = null;
        int pos = 0;
        int auxOcc = 0;

        if (tag <= 0) {
            throw new BrumaException("parameter out of range tag[" + tag +
                                                                    "] <= 0");
        }
        if  (occ <= 0) {
            throw new BrumaException("parameter out of range occ[" + occ +
                                                                    "] <= 0");
        }
        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getId() == tag) {
                auxOcc++;
                if (auxOcc == occ) {
                    break;
                }
            }
            pos++;
        }
        return (field == null) ? null : field.toXML();
    }

    /**
     *  Get a record field using the following xml format:
     *  &lt;tagStr&gt;field content&lt;/tagStr&gt&
     *
     * @param tagStr the field tag string.
     * @param occ the field tag occurrence (occ > 0).
     * @return  the record field.
     * @exception  BrumaException
     */
    public String getFieldXML(final String tagStr,
                              final int occ) throws BrumaException {
        final int len = fields.size();
        Field field = null;
        int pos = 0;
        int auxOcc = 0;

        if (tagStr == null) {
            throw new BrumaException("null tagStr");
        }
        if  (occ <= 0) {
            throw new BrumaException("parameter out of range occ[" + occ +
                                                                    "] <= 0");
        }
        while (pos < len) {
            field = fields.get(pos);
            if (field == null) {
                throw new BrumaException("null field");
            }
            if (field.getIdStr().equals(tagStr)) {
                auxOcc++;
                if (auxOcc == occ) {
                    break;
                }
            }
            pos++;
        }
        return (field == null) ? null : field.toXML();
    }

    /**
     *  Get all record fields.
     *
     * @return  a list of record field objects (<code>Field</code>).
     * @exception  BrumaException
     */
    public List<Field> getFields() throws BrumaException {
        return fields;
    }

    /**
     *  Get all record fields using the following pseudo xml format:
     *  &lt;tag&gt;field content&lt;/tag&gt;
     *  &lt;tag&gt;field content&lt;/tag&gt;
     *  &lt;tag&gt;field content&lt;/tag&gt;
     *
     * @return  all record fields in XML format.
     * @exception  BrumaException
     */
    public String getFieldsWithTags() throws BrumaException {
        final StringBuilder buf = new StringBuilder();
        final int len = fields.size();

        String fld;

        for (int counter = 0; counter < len; counter++) {
            fld = getFieldWithTag(counter);
            assert (fld != null);
            buf.append(fld);
            buf.append(separator);
        }

        return buf.toString();
    }

    /**
     *  Get all record fields using the following xml format:
     *  &lt;field tag='tag'&gt;field content&lt;/field&gt;
     *  &lt;field tag='tag'&gt;field content&lt;/field&gt;
     *  &lt;field tag='tag'&gt;field content&lt;/field&gt;
     *
     * @return  all record fields in XML format.
     * @exception  BrumaException
     */
    public String getFieldsXML() throws BrumaException {
        final StringBuilder buf = new StringBuilder();
        final int len = fields.size();

        String fld;

        for (int counter = 0; counter < len; counter++) {
            fld = getFieldXML(counter);
            assert (fld != null);
            buf.append(fld);
            buf.append(separator);
        }

        return buf.toString();
    }

    /**
     *  Adds a record field.
     *
     * @param field record field.
     * @return  this object (Record).
     * @exception  BrumaException
     */
    public Record addField(final Field field)  throws BrumaException {
        if (field == null) {
            throw new BrumaException("null field");
        }
        if (fields.size() > 32767) {
            throw new BrumaException("nvf > 32767");
        }

        fields.add(field);

        return this;
    }

    /**
     *  Adds a record field.
     *
     * @param tag the field tag (0 <= tag <= 32767).
     * @param field the field content.
     * @return  this object (Record).
     * @exception  BrumaException
     */
    public Record addField(final int tag,
                           final CharSequence field) throws BrumaException {

        if ((tag <= 0) || (tag > 32767)) {
            throw new BrumaException("tag[" + tag
                                + "] parameter out of range[1,32767]");
        }
        if (field == null) {
            throw new BrumaException("null field content");
        }

        if (fields.size() > 32767) {
            throw new BrumaException("nvf > 32767");
        }
        fields.add(new Field(tag, field));

        return this;
    }

    /**
     *  Adds a record field.
     *
     * @param strId the field tag string.
     * @param field the field content.
     * @return  this object (Record).
     * @exception  BrumaException
     */
    public Record addField(final CharSequence strId,
                           final CharSequence field) throws BrumaException {

        if (strId == null) {
            throw new BrumaException("null strId");
        }
        if (field == null) {
            throw new BrumaException("null field content");
        }

        if (fields.size() > 32767) {
            throw new BrumaException("nvf > 32767");
        }
        fields.add(new Field(strId, field));

        return this;
    }

    /**
     *  Adds a record field.
     *
     * @param tag the field tag (0 < tag <= 9999) if strId == null..
     * @param strId the field tag string.
     * @param field the field content.
     * @return  this object (Record).
     * @exception  BrumaException
     */
    public Record addField(final int tag,
                            final CharSequence strId,
                            final CharSequence field) throws BrumaException {

        if (((tag <= 0) || (tag > 32767)) && (strId == null)) {
            throw new BrumaException("tag[" + tag
                                + "] parameter out of range[1,32767]");
        }
        if (field == null) {
            throw new BrumaException("null field content");
        }

        if (fields.size() > 32767) {
            throw new BrumaException("nvf > 32767");
        }
        fields.add(new Field(tag, strId, field));

        return this;
    }

    /**
     *  Adds record field from a list
     *
     * @param fields the list of fields objecs (FieldEntry).
     * @return  this object (Record)
     * @exception  BrumaException
     */
    public Record addFields(final List<Field> fields) throws BrumaException {
        if (fields == null) {
            throw new BrumaException("null field list");
        }

        for (Field field : fields) {
            if (field != null) {
                addField(field.getId(), field.getContent());
            }
        }
        return this;
    }

    /**
     *  Deletes a record field.
     *
     * @param tag the field tag (tag > 0).
     * @param occ the field tag occurrence. (occ >= 0), occ = 0 deletes
     * all occurrences.
     * @return  this object (Record).
     * @exception  BrumaException
     */
    public Record deleteField(final int tag,
                              final int occ) throws BrumaException {
        int auxOcc = 0;
        Field field;

        if  ((tag <= 0) || (tag > 32767)) {
            throw new BrumaException("tag[" + tag +
                                "] parameter out of range[1," + 32767 + "]");
        }
        if  (occ < 0) {
            throw new BrumaException("occ[" + occ +
                                            "] parameter out of range < 0");
        }

        for (Iterator<Field> i = fields.iterator(); i.hasNext();) {
           field = i.next();
            if  (field.getId() == tag) {
                auxOcc++;
                if  ((occ == auxOcc) || (occ == 0))  {
                    i.remove();
                    if (occ == auxOcc) {
                        break;
                    }
                }
            }
        }

        return this;
    }

    /**
     *  Deletes a record field.
     *
     * @param strId the field name string.
     * @param occ the field tag occurrence. (occ >= 0), occ = 0 deletes
     * all occurrences.
     * @return  this object (Record).
     * @exception  BrumaException
     */
    public Record deleteField(final CharSequence strId,
                              final int occ) throws BrumaException {
        int auxOcc = 0;
        Field field;

        if  (strId == null) {
            throw new BrumaException("null tag string");
        }
        if  (occ < 0) {
            throw new BrumaException("occ[" + occ +
                                            "] parameter out of range < 0");
        }
        for (Iterator<Field> i = fields.iterator(); i.hasNext();) {
           field = i.next();
            if  (field.getIdStr().equals(strId)) {
                auxOcc++;
                if  ((occ == auxOcc) || (occ == 0))  {
                    i.remove();
                    if (occ == auxOcc) {
                        break;
                    }
                }
            }
        }

        return this;
     }


    /**
     *  Deletes all record fields.
     *
     * @return  this object (Record).
     */
    public Record deleteFields() {
        fields.clear();

        return this;
    }

    /**
     *  Sets the record master file number (mfn).
     *
     * @param mfn the master file number (mfn > 0).
     * @return  this object (Record).
     * @exception  BrumaException
     */
    public Record setMfn(final int mfn) throws BrumaException {
        if (mfn < 0) {
            throw new BrumaException("mfn[" + mfn + "] out of range < 0");
        }
        this.mfn = mfn;

        return this;
    }

    /**
     *  Deletes all record fields and changes its status to new.
     * @return  this object (Record).
     */
    public Record changeToNew() {
        mfn = 0;
        status = Status.ACTIVE;
        actStatus = ActiveStatus.NEW;
        fields.clear();

        return this;
    }

    public Record sortFields() {
        Collections.sort(fields);

        return this;
    }

    @Override
    public Iterator<Field> iterator() {
        Iterator<Field> ret;

        try {
            ret = getFields().iterator();
        } catch(BrumaException ze) {
            ret = null;
        }

        return ret;
    }

    /**
     *  Displays the record with the following xml format:
     *  &lt;record mfn='mfn' nvf='nvf' status=status'&gt;
     *    &lt;field='tag'&gt;field content&lt;/field&lt;
     *    &lt;field='tag'&gt;field content&lt;/field&lt;
     *    &lt;field='tag'&gt;field content&lt;/field&lt;
     *  &lt;/record&gt;
     *
     * @return  the record in XML format.
     * @exception  BrumaException
     */
    public String toXML() throws BrumaException {
        final StringBuilder buf = new StringBuilder();
        final int len = fields.size();

        String fld;

        buf.append("<record mfn='");
        buf.append(mfn);
        buf.append("' nvf='");
        buf.append(getNvf());
        buf.append("' status='");
        buf.append(status);
        buf.append("'>");
        buf.append(separator);

        for (int counter = 0; counter < len; counter++) {
            fld = getFieldXML(counter);
            assert (fld != null);
            buf.append("  ");
            buf.append(fld);
            buf.append(separator);
        }
        buf.append("</record>");
        buf.append(separator);

        return buf.toString();
    }

    /**
     *  Displays the record with the following pseudo xml format:
     *  &gt;record mfn='mfn' nvf='nvf' status='status'&lt;
     *    &gt;tag&lt;field content&gt;/tag&lt;
     *    &gt;tag&lt;field content&gt;/tag&lt;
     *    &gt;tag&lt;field content&gt;/tag&lt;
     *  &gt;/record&lt;
     *
     * @return  the record in XML format.
     */
    @Override
    public String toString() {
        final StringBuilder buf = new StringBuilder();
        final int len = fields.size();

        String fld;

        buf.append("<record mfn='");
        buf.append(mfn);
        buf.append("' nvf='");
        buf.append(getNvf());
        buf.append("' status='");
        buf.append(status);
        buf.append("'>");
        buf.append(separator);

        for (int counter = 0; counter < len; counter++) {
            try {
                fld = getFieldWithTag(counter);
            } catch (BrumaException ex) {
                return null;
            }
            assert (fld != null);
            buf.append("  ");
            buf.append(fld);
            buf.append(separator);
        }
        buf.append("</record>");
        buf.append(separator);

        return buf.toString();
    }

    public String toJSON() throws BrumaException {
        final StringBuilder builder = new StringBuilder();
        final List<Field> sFields = new ArrayList<Field>();
        final List<Subfield> sSubFields = new ArrayList<Subfield>();
        boolean firstFld = true;
        boolean firstSub;
        int lastFldId = 0;
        int lstSubId;

        for (Field fld: fields) {
            sFields.add(fld);
        }
        Collections.sort(sFields);

        builder.append("{\n  \"mfn\" : \"");
        builder.append(mfn);
        builder.append("\",\n  \"_nvf\" : ");
        builder.append(getNvf());
        builder.append("");

        for (Field fld: sFields) {
            if (fld.getId() == lastFldId) {
                builder.append(",\n    {      ");
            } else {
                lastFldId = fld.getId();
                if (firstFld) {
                    firstFld = false;
                    builder.append(",");
                } else {
                    builder.append("\n  ],");
                }
                builder.append("\n  \"v");
                builder.append(fld.getId());
                builder.append("\" : [\n    {      ");
            }
            sSubFields.clear();
            lstSubId = 0;
            firstSub = true;

            for (Subfield sub: fld.getSubfields()) {
                sSubFields.add(sub);
            }
            Collections.sort(sSubFields);

            for (Subfield sub: sSubFields) {
                if (sub.getId() == lstSubId) {
                    builder.append(", ");
                } else {
                    lstSubId = sub.getId();
                    if (firstSub) {
                        firstSub = false;
                    } else {
                        builder.append("],");
                    }
                    builder.append("\n      \"");
                    builder.append(sub.getId());
                    builder.append("\" : [");
                }
                builder.append("\"");
                builder.append(sub.getContent().replace("\"", "&quot;"));
                builder.append("\"");
            }
            if (!sSubFields.isEmpty()) {
                builder.append("]");
            }
            builder.append("\n    }");
        }
        if (! sFields.isEmpty()) {
            builder.append("\n  ]");
        }
        builder.append("\n}");

        return builder.toString();
    }

    public String toJSON2() throws BrumaException {
        final StringBuilder builder = new StringBuilder();
        boolean firstFld = true;
        boolean firstSub;

        builder.append("{\n  \"mfn\" : \"");
        builder.append(mfn);
        builder.append("\",\n  \"_nvf\" : ");
        builder.append(getNvf());
        builder.append(",\n  \"fields\" : [");

        for (Field fld: fields) {
            if (firstFld) {
                firstFld = false;
            } else {
                builder.append(",");
            }
            builder.append("\n    {\n      \"v");
            builder.append(fld.getId());
            builder.append("\" : [");

            firstSub = true;
            for (Subfield sub: fld.getSubfields()) {
                if (firstSub) {
                    firstSub = false;
                } else {
                    builder.append(",");
                }
                builder.append("\n        {\"");
                builder.append(sub.getId());
                builder.append("\" : \"");
                builder.append(sub.getContent().replace("\"", "&quot;"));
                builder.append("\"}");
            }
            builder.append("\n      ]\n    }");
        }
        builder.append("\n  ]\n}");

        return builder.toString();
    }

    public String toJSON3(final int idTag) throws BrumaException {
        final StringBuilder builder = new StringBuilder();
        final Map<Integer, List<Field>> flds =
                                        new TreeMap<Integer,List<Field>> ();
        final Map<Character, List<Subfield>> subflds =
                                        new TreeMap<Character,List<Subfield>>();
        List<Field> fldLst;
        List<Subfield> subFldLst;
        boolean fldFirst;
        boolean subMultiFirst;
        boolean subFirst;
        boolean subMulti;
        int size;
        int cur = 0;
        int rtag = mfn;

        if (idTag > 0) {
            final Field f = getField(idTag,1);
            if (f != null) {
                final String sf = f.getContent();
                if ((sf != null) && !sf.isEmpty()) {
                    rtag = Integer.parseInt(sf);
                }
            }
        }

        builder.append("  {\n    \"_id\" : \"");
        builder.append(Integer.toString(rtag));
        builder.append("\",\n    \"_nvf\" : ");
        builder.append(getNvf());
        //builder.append("\"");

        for (Field fld: fields) {
            fldLst = flds.get(fld.getId());
            if (fldLst == null) {
                fldLst = new ArrayList<Field>();
                flds.put(fld.getId(), fldLst);
            }
            fldLst.add(fld);
        }

        size = flds.size();

        for (Map.Entry<Integer,List<Field>> entry : flds.entrySet()) {
            final Integer itag = entry.getKey();
            //final String stag = tags.get(itag);
            final String stag = entry.getValue().get(0).getIdStr();
            fldLst = entry.getValue();

            if (++cur <= size) {
                builder.append(",");
            }
            builder.append("\n    ");
            if (stag == null) {
                builder.append("\"v");
                builder.append(itag);
            } else {
                builder.append("\"");
                builder.append(stag);
            }
            builder.append("\" : ");
            if (fldLst.size() > 1) {
                builder.append("[");
            }
            fldFirst = true;

            for (Field fld : fldLst) {
                if (fldFirst) {
                    fldFirst = false;
                } else {
                    builder.append(",");
                }
                builder.append("\n      {");
                subflds.clear();
                for (Subfield sub: fld) {
                    subFldLst = subflds.get(sub.getId());
                    if (subFldLst == null) {
                        subFldLst = new ArrayList<Subfield>();
                        subflds.put(sub.getId(), subFldLst);
                    }
                    subFldLst.add(sub);
                }
                subFirst = true;
                for (Map.Entry<Character,List<Subfield>> entrys
                                                         : subflds.entrySet()) {
                    subFldLst = entrys.getValue();
                    subMulti = (subFldLst.size() > 1);
                    subMultiFirst = true;

                    if (subFirst) {
                        subFirst = false;
                    } else {
                        builder.append(",");
                    }
                    builder.append("\n         \"");
                    builder.append(entrys.getKey());
                    builder.append("\" : ");
                    if (subMulti) {
                        builder.append("[");
                    }
                    for (Subfield sub : subFldLst) {
                        if (subMulti) {
                            if (subMultiFirst) {
                                subMultiFirst = false;
                            } else {
                                builder.append(", ");
                            }
                        }
                        builder.append("\"");
                        builder.append(sub.getContent()
                                          .replace("\\", "\\\\")
                                          .replace("\"", "\\\""));
                        builder.append("\"");
                    }
                    if (subMulti) {
                        builder.append("]");
                    }
                }
                builder.append("\n      }");
            }

            if (fldLst.size() > 1) {
                builder.append("\n    ]");
            }
        }
        builder.append("\n  }");

        return builder.toString();
    }
}
